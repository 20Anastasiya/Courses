# Если помните, на старых мобильных телефонах текстовые сообщения на бирались
# при помощи цифровых кнопок. При этом одна кнопка была ассоциирована сразу с
# несколькими буквами, а выбор зависел от количества нажатий на кнопку.
# Однократное нажатие приводило к появлению первой буквы в соответствующем этой
# кнопке списке, последующие нажатия меняли ее на следующую. Список символов,
# ассоциированных с цифровой панелью, приведен в табл.
# Кнопка | Символы
# -------------------
# 1      | . , ? !
# 2      | A B C
# 3      | D E F
# 4      | G H I
# 5      | J K L
# 6      | M N O
# 7      | P Q R S
# 8      | T U V
# 9      | W X Y Z
# 0      | Пробел
#
# Напишите программу, отображающую последовательность кнопок, которую необходимо
# нажать, чтобы на экране телефона появился текст, введенный пользователем.
# Создайте словарь, сопоставляющий символы с кнопками, которые необходимо
# нажать, а затем воспользуйтесь им для вывода на экран последовательности
# кнопок в соответствии с введенны


def get_str(welcom_message):
    _str = input(welcom_message)
    return _str


def get_key_by_value(_dict, val):
    for key, value in _dict.items():
        if val.upper() in value:
            return key


def get_number_code(message):
    buttons = {1: ('.', ',', '?', '!'),
               2: ('A', 'B', 'C'),
               3: ('D', 'E', 'F'),
               4: ('G', 'H', 'I'),
               5: ('J', 'K', 'L'),
               6: ('M', 'N', 'O'),
               7: ('P', 'Q', 'R', 'S'),
               8: ('T', 'U', 'V'),
               9: ('W', 'X', 'Y', 'Z'),
               0: (' ',)}
    numbers = []
    for letter in message:
        num = get_key_by_value(buttons, letter)
        numbers.extend([num] * (buttons[num].index(letter.upper()) + 1))
    return ''.join(map(str, numbers))


if __name__ == '__main__':
    message = get_str('Введите сообщение: ')
    print(get_number_code(message))
